#-------------------------------------------------------------------------
#Core.py -- the computation routines
#Compiler Generator Coco/R,
#Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
#extended by M. Loeberbauer & A. Woess, Univ. of Linz
#ported from Java to Python by Ronald Longo
#
#This program is free software; you can redistribute it and/or modify it
#under the terms of the GNU General Public License as published by the
#Free Software Foundation; either version 2, or (at your option) any
#later version.
#
#This program is distributed in the hope that it will be useful, but
#WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#for more details.
#
#You should have received a copy of the GNU General Public License along
#with this program; if not, write to the Free Software Foundation, Inc.,
#59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#As an exception, it is allowed to write an extension of Coco/R that is
#used as a plugin in non-free software.
#
#If not otherwise stated, any source coe generated by Coco/R (other than
#Coco/R itself) does not fall under the GNU General Public License.
#-------------------------------------------------------------------------*/
from typing import List, Optional, Set, Union
from enum import IntEnum
import os
from pathlib import Path
import sys
import copy
from optparse import OptionParser

from .Trace import Trace
from .Errors import Errors
from .CharClass import CharClass

INDENT = "\t"


class Comment(object):
	""" info about comment syntax"""

	first = None  # list of comments

	def __init__(self, frm: "Node", to: "Node", nested: bool) -> None:
		assert isinstance(frm, Node)
		assert isinstance(to, Node)
		assert isinstance(nested, bool)
		self.start = self.Str(frm)
		self.stop = self.Str(to)
		self.nested = nested
		self.next = Comment.first
		Comment.first = self

	def Str(self, p: "Node") -> str:
		assert isinstance(p, Node)
		s = ""  # StringBuffer
		while p is not None:
			if p.typ == NodeKind.chr:
				s += chr(p.val)
			elif p.typ == NodeKind.clas:
				st = CharClass.Set(p.val)  # BitSet
				if len(st) != 1:
					Errors.SemErr("character set contains more than 1 character")
				s += chr(min(st))
				# s += chr(st.First())
			else:
				Errors.SemErr("comment delimiters may not be structured")
			p = p.next
		if len(s) == 0 or len(s) > 2:
			Errors.SemErr("comment delimiters must be 1 or 2 characters long")
			s = "?"
		return s


class Symbol(object):
	terminals = []  # of Symbol
	pragmas = []
	nonterminals = []

	# token kinds
	fixedToken = 0  # e.g. 'a' ('b' | 'c') (structure of literals)
	classToken = 1  # e.g. digit {digit}   (at least one char class)
	litToken = 2  # e.g. "while"
	classLitToken = 3  # e.g. letter {letter} but without literals that have the same structure

	def __init__(self, typ: int, name: str, line: int) -> None:
		assert isinstance(typ, int)
		assert isinstance(name, str)
		assert isinstance(line, int)
		self.n = 0  # symbol number
		self.typ = 0  # t, nt, pr, unknown, rslv
		self.name = 0  # symbol name
		self.graph = None  # Node,  nt: to first node of syntax graph
		self.tokenKind = 0  # t:  token kind (fixedToken, classToken, ...)
		self.deletable = False  # nt: true if nonterminal is deletable
		self.firstReady = False  # nt: true if terminal start symbols have already been computed
		self.first = None  # set,   nt: terminal start symbols
		self.follow = None  # set,   nt: terminal followers
		self.nts = None  # set,   nt: nonterminals whose followers have to be added to this sym
		self.line = 0  # source text line number of item in this node
		self.attrPos = None  # Position,   nt: position of attributes in source text (or None)
		self.semPos = None  # Position,   pr: pos of semantic action in source text (or None)
		#             nt: pos of local declarations in source text (or None)
		self.retType = ""  # AH - nt: Type of output attribute (or None)
		self.retVar = None  # str - AH - nt: Name of output attribute (or None)
		self.symName = None  # str,   symbolic name /* pdt */

		if len(name) == 2 and name[0] == '"':
			Errors.SemErr("empty token not allowed")
			name = "???"

		self.typ = typ
		self.name = name
		self.line = line

		if typ == NodeKind.t:
			self.n = len(Symbol.terminals)
			Symbol.terminals.append(self)
		elif typ == NodeKind.pr:
			Symbol.pragmas.append(self)
		elif typ == NodeKind.nt:
			self.n = len(Symbol.nonterminals)
			Symbol.nonterminals.append(self)

	@staticmethod
	def Find(name: str) -> Optional["Symbol"]:
		assert isinstance(name, str)

		for s in Symbol.terminals:
			if s.name == name:
				return s

		for s in Symbol.nonterminals:
			if s.name == name:
				return s

		return None

	def compareTo(self, x):
		assert isinstance(x, Symbol)
		return self.name.__cmp__(x.name)


class Target(object):
	""" set of states that are reached by an action"""

	def __init__(self, s: "State") -> None:
		assert isinstance(s, State)
		self.state = s  # target state
		self.next = None  # Target instance


class NodeKind(IntEnum):
	# constants for node kinds
	t = 1  # terminal symbol
	pr = 2  # pragma
	nt = 3  # nonterminal symbol
	clas = 4  # character class
	chr = 5  # character
	wt = 6  # weak terminal symbol
	any = 7  #
	eps = 8  # empty
	sync = 9  # synchronization symbol
	sem = 10  # semantic action: (. .)
	alt = 11  # alternative: |
	iter = 12  # iteration: { }
	opt = 13  # option: [ ]
	rslv = 14  # resolver expr  /* ML */ /* AW 03-01-13 renamed slv --> rslv */


class Node(object):
	nodes = []
	nTyp = ["\t ", "t   ", "pr  ", "nt  ", "clas", "chr ", "wt  ", "any ", "eps ", "sync", "sem ", "alt ", "iter", "opt ", "rslv"]

	normalTrans = 0  # transition codes
	contextTrans = 1

	def __init__(self, typ: int, symOrNodeOrInt: Optional[Union[int, "Node", Symbol]], line: Optional[int] = None) -> None:
		assert isinstance(typ, int)
		assert isinstance(symOrNodeOrInt, Symbol) or isinstance(symOrNodeOrInt, Node) or isinstance(symOrNodeOrInt, int) or (symOrNodeOrInt is None)
		assert isinstance(line, int) or (line is None)

		self.n = 0  # node number
		self.typ = 0  # t, nt, wt, chr, clas, any, eps, sem, sync, alt, iter, opt, rslv
		self.next = None  # Node,   to successor node
		self.down = None  # Node,   alt: to next alternative
		self.sub = None  # Node,   alt, iter, opt: to first node of substructure
		self.up = False  # true: "next" leads to successor in enclosing structure
		self.sym = None  # Symbol,   nt, t, wt: symbol represented by this node
		self.val = 0  # chr:  ordinal character value
		# clas: index of character class
		self.code = 0  # chr, clas: transition code
		self.set = None  # set,   any, sync: the set represented by this node
		self.pos = None  # Position,   nt, t, wt: pos of actual attributes
		#             sem:       pos of semantic action in source text
		self.line = 0  # source text line number of item in this node
		self.state = None  # State,   DFA state corresponding to this node
		#          (only used in DFA.ConvertToStates)
		self.retVar = None  # str, nt: name of output attribute (or None)

		if isinstance(symOrNodeOrInt, int) and isinstance(line, int):
			self.typ = typ
			self.sym = None
			self.line = line
			self.n = len(Node.nodes)
			Node.nodes.append(self)
			self.val = symOrNodeOrInt
		elif line is None:
			self.typ = typ
			self.sym = None
			self.line = 0
			self.n = len(Node.nodes)
			Node.nodes.append(self)
			self.sub = symOrNodeOrInt
		else:
			self.typ = typ
			self.sym = symOrNodeOrInt
			self.line = line
			self.n = len(Node.nodes)
			Node.nodes.append(self)

	@staticmethod
	def DelGraph(p: Optional["Node"]) -> bool:
		return (p is None) or Node.DelNode(p) and Node.DelGraph(p.next)

	@staticmethod
	def DelSubGraph(p: Optional["Node"]) -> bool:
		return p is None or Node.DelNode(p) and (p.up or Node.DelSubGraph(p.next))

	@staticmethod
	def DelAlt(p: Optional["Node"]) -> bool:
		return p is None or Node.DelNode(p) and (p.up or Node.DelAlt(p.next))

	@staticmethod
	def DelNode(p: "Node") -> bool:
		if p.typ == NodeKind.nt:
			return p.sym.deletable
		elif p.typ == NodeKind.alt:
			return Node.DelAlt(p.sub) or p.down is not None and Node.DelAlt(p.down)
		else:
			return p.typ in (NodeKind.eps, NodeKind.iter, NodeKind.opt, NodeKind.sem, NodeKind.sync, NodeKind.rslv)

	# ----------------- for printing ----------------------

	@staticmethod
	def Ptr(p, up):
		assert isinstance(p, Node) or (p is None)
		assert isinstance(up, bool)
		if p is None:
			return 0
		elif up:
			return -p.n
		else:
			return p.n

	@staticmethod
	def Pos(pos):
		if pos is None:
			return INDENT + "  "
		else:
			return Trace.formatString(str(pos.beg), 5)

	@staticmethod
	def Name(name):
		assert isinstance(name, str)
		return (name + INDENT * 3 + "  ")[0:12]
		# found no simpler way to get the first 12 characters of the name
		# padded with blanks on the right

	@staticmethod
	def PrintNodes():
		Trace.WriteLine("Graph nodes:")
		Trace.WriteLine("----------------------------------------------------")
		Trace.WriteLine(INDENT + "n type name          next  down   sub   pos  line")
		Trace.WriteLine(INDENT * 10 + "       val  code")
		Trace.WriteLine("----------------------------------------------------")

		for p in Node.nodes:
			Trace.Write(str(p.n), 4)
			Trace.Write(" " + Node.nTyp[p.typ] + " ")
			if p.sym is not None:
				Trace.Write(Node.Name(p.sym.name), 12)
				Trace.Write(" ")
			elif p.typ == NodeKind.clas:
				c = CharClass.classes[p.val]
				Trace.Write(Node.Name(c.name), 12)
				Trace.Write(" ")
			else:
				Trace.Write(INDENT * 4 + " ")

			Trace.Write(str(Node.Ptr(p.next, p.up)), 5)
			Trace.Write(" ")

			if p.typ in (NodeKind.t, NodeKind.nt, NodeKind.wt):
				Trace.Write(" \t\t\t\t")
				Trace.Write(Node.Pos(p.pos), 5)
			elif p.typ == NodeKind.chr:
				Trace.Write(str(p.val), 5)
				Trace.Write(" ")
				Trace.Write(str(p.code), 5)
				Trace.Write(INDENT * 2 + " ")
			elif p.typ == NodeKind.clas:
				Trace.Write(INDENT * 2 + "")
				Trace.Write(str(p.code), 5)
				Trace.Write(INDENT * 2 + " ")
			elif p.typ in (NodeKind.alt, NodeKind.iter, NodeKind.opt):
				Trace.Write(str(Node.Ptr(p.down, False)), 5)
				Trace.Write(" ")
				Trace.Write(str(Node.Ptr(p.sub, False)), 5)
				Trace.Write(INDENT * 2 + " ")
			elif p.typ == NodeKind.sem:
				Trace.Write(INDENT * 4 + " ")
				Trace.Write(Node.Pos(p.pos), 5)
			elif p.typ in (NodeKind.eps, NodeKind.any, NodeKind.sync):
				Trace.Write(INDENT * 6 + "")

			Trace.WriteLine(str(p.line), 5)

		Trace.WriteLine()


class State(object):
	""" state of finite automaton"""

	lastNr = 0  # highest state number

	def __init__(self, dfa) -> None:
		self.nr = 0  # state number
		self.firstAction = None  # Action,  to first action of this state
		self.endOf = None  # Symbol,  recognized token if state is final
		self.ctx = False  # true if state is reached via contextTrans
		self.next = None  # State

		State.lastNr += 1
		self.nr = State.lastNr
		self.dfa = dfa

	def AddAction(self, act: "Action") -> None:
		assert isinstance(act, Action)
		lasta = None  # Action
		a = self.firstAction  # Action
		while (a is not None) and (act.typ >= a.typ):
			lasta = a
			a = a.next
		# collecting classes at the beginning gives better performance
		act.next = a
		if a == self.firstAction:
			self.firstAction = act
		else:
			lasta.next = act

	def DetachAction(self, act: "Action") -> None:
		assert isinstance(act, Action)
		lasta = None  # Action
		a = self.firstAction  # Action
		while (a is not None) and a != act:
			lasta = a
			a = a.next
		if a is not None:
			if a == self.firstAction:
				self.firstAction = a.next
			else:
				lasta.next = a.next

	def TheAction(self, ch: str) -> Optional["Action"]:
		assert isinstance(ch, str)
		if isinstance(ch, str):
			ch = ord(ch)
		a = self.firstAction
		while a is not None:
			if a.typ == NodeKind.chr and ch == a.sym:
				return a
			elif a.typ == NodeKind.clas:
				s = CharClass.Set(a.sym)
				if ch in s:
					return a
			a = a.next
		return None

	def MeltWith(self, s: "State") -> None:
		"""copy actions of s to state"""
		assert isinstance(s, State)
		action = s.firstAction
		while action is not None:
			a = Action(action.typ, action.sym, action.tc, self.dfa)
			a.AddTargets(action)
			self.AddAction(a)
			action = action.next


class Action(object):
	""" action of finite automaton"""

	def __init__(self, typ: int, sym: int, tc: int, dfa) -> None:
		assert isinstance(typ, int)
		assert isinstance(sym, int)
		assert isinstance(tc, int)
		self.typ = typ  # type of action symbol: clas, chr
		self.sym = sym  # action symbol
		self.tc = tc  # transition code: normalTrans, contextTrans
		self.target = None  # Target    # states reached from this action
		self.next = None  # Action
		self.dfa = dfa

	def AddTarget(self, t: Target) -> None:
		""" add t to the action.targets"""
		assert isinstance(t, Target)
		last = None  # Target
		p = self.target  # Target
		while (p is not None) and (t.state.nr >= p.state.nr):
			if t.state == p.state:
				return
			last = p
			p = p.next
		t.next = p
		if p == self.target:
			self.target = t
		else:
			last.next = t

	def AddTargets(self, a: "Action") -> None:
		"""add copy of a.targets to action.targets"""
		assert isinstance(a, Action)
		p = a.target
		while p is not None:
			t = Target(p.state)
			self.AddTarget(t)
			p = p.next
		if a.tc == Node.contextTrans:
			self.tc = Node.contextTrans

	def Symbols(self) -> Union[Set[int], Set[Union[int, str]]]:
		if self.typ == NodeKind.clas:
			s = copy.copy(CharClass.Set(self.sym))
		else:
			s = set()
			s.add(self.sym)
		return s

	def ShiftWith(self, s: Set[int]) -> None:
		if len(s) == 1:
			self.typ = NodeKind.chr
			self.sym = min(s)  # .First()
		else:
			c = CharClass.Find(s)
			if c is None:
				c = CharClass("#", s, self.dfa.trace)  # class with dummy name
			self.typ = NodeKind.clas
			self.sym = c.n

	def GetTargetStates(self, param: List[None]) -> bool:
		assert isinstance(param, list)  # Object[]
		# compute the set of target states
		targets = set()  # BitSet
		endOf = None  # Symbol
		ctx = False  # boolean
		t = self.target
		while t is not None:
			stateNr = t.state.nr  # int
			if stateNr <= self.dfa.lastSimState:
				targets.add(stateNr)
			else:
				try:
					targets |= Melted.Set(stateNr)
				except BaseException:
					print(sys.exc_info()[1])
					Errors.count += 1
			if t.state.endOf is not None:
				if (endOf is None) or (endOf == t.state.endOf):
					endOf = t.state.endOf
				else:
					print("Tokens " + endOf.name + " and " + t.state.endOf.name + " cannot be distinguished")
					Errors.count += 1
			if t.state.ctx:
				ctx = True
			t = t.next
		param[0] = targets
		param[1] = endOf
		return ctx


class Melted(object):  # info about melted states
	first = None  # Melted instance,   head of melted state list

	def __init__(self, st: Set[int], state: State) -> None:
		assert isinstance(st, set)
		assert isinstance(state, State)
		self.set = st  # set of old states
		self.state = state  # new state
		self.next = Melted.first  # Melted instance
		Melted.first = self

	@staticmethod
	def StateWithSet(s: Set[int]) -> Optional["Melted"]:
		assert isinstance(s, set)
		m = Melted.first
		while m is not None:
			if s == m.set:  # s.equals( m.set ):
				return m
			m = m.next
		return None

	@staticmethod
	def Set(nr):
		assert isinstance(nr, int)
		m = Melted.first
		while m is not None:
			if m.state.nr == nr:
				return m.set
			else:
				m = m.next
		raise RuntimeError("-- compiler error in Melted.Set()")


class Graph(object):
	dummyNode = Node(NodeKind.eps, None, 0)

	def __init__(self, dfa, p: Optional[Node] = None) -> None:
		self.dfa = dfa
		assert isinstance(p, Node) or (p is None)

		self.l = p  # Node,  left end of graph = head
		self.r = p  # Node,  right end of graph = list of nodes to be linked to successor graph

	@staticmethod
	def MakeFirstAlt(g: "Graph") -> None:
		assert isinstance(g, Graph)
		g.l = Node(NodeKind.alt, g.l)
		g.l.line = g.l.sub.line  # make line available for error handling */
		g.l.next = g.r
		g.r = g.l

	@staticmethod
	def MakeAlternative(g1: "Graph", g2: "Graph") -> None:
		assert isinstance(g1, Graph)
		assert isinstance(g2, Graph)
		g2.l = Node(NodeKind.alt, g2.l)
		g2.l.line = g2.l.sub.line
		p = g1.l
		while p.down is not None:
			p = p.down
		p.down = g2.l
		p = g1.r
		while p.next is not None:
			p = p.next
		p.next = g2.r

	@staticmethod
	def MakeSequence(g1: "Graph", g2: "Graph") -> None:
		assert isinstance(g1, Graph)
		assert isinstance(g2, Graph)
		p = g1.r.next
		g1.r.next = g2.l  # link head node
		while p is not None:  # link substructure
			q = p.next
			p.next = g2.l
			p.up = True
			p = q
		g1.r = g2.r

	@staticmethod
	def MakeIteration(g: "Graph") -> None:
		assert isinstance(g, Graph)
		g.l = Node(NodeKind.iter, g.l)
		p = g.r
		g.r = g.l
		while p is not None:
			q = p.next
			p.next = g.l
			p.up = True
			p = q

	@staticmethod
	def MakeOption(g: "Graph") -> None:
		assert isinstance(g, Graph)
		g.l = Node(NodeKind.opt, g.l)
		g.l.next = g.r
		g.r = g.l

	@staticmethod
	def Finish(g: "Graph") -> None:
		assert isinstance(g, Graph)
		p = g.r
		while p is not None:
			q = p.next
			p.next = None
			p = q

	@staticmethod
	def SetContextTrans(p: Node) -> None:
		"""set transition code in the graph rooted at p"""
		assert isinstance(p, Node) or (p is None)
		self.dfa.hasCtxMoves = True
		while p is not None:
			if p.typ == NodeKind.chr or p.typ == NodeKind.clas:
				p.code = Node.contextTrans
			elif p.typ == NodeKind.opt or p.typ == NodeKind.iter:
				Graph.SetContextTrans(p.sub)
			elif p.typ == NodeKind.alt:
				Graph.SetContextTrans(p.sub)
				Graph.SetContextTrans(p.down)
			if p.up:
				break
			p = p.next

	@staticmethod
	def DeleteNodes() -> None:
		Node.nodes = []
		Graph.dummyNode = Node(NodeKind.eps, None, 0)

	@staticmethod
	def StrToGraph(st: str, dfa) -> "Graph":
		assert isinstance(st, str)
		s = DFA.Unescape(st[1:-1])
		if len(s) == 0:
			Errors.SemErr("empty token not allowed")
		g = Graph(dfa)
		g.r = Graph.dummyNode
		for i in range(0, len(s)):
			p = Node(NodeKind.chr, ord(s[i]), 0)
			g.r.next = p
			g.r = p
		g.l = Graph.dummyNode.next
		Graph.dummyNode.next = None
		return g


class UserDefinedTokenName(object):
	NameTab = []
	alias = ""
	name = ""

	def __init__(self, alias, name):
		assert isinstance(alias, str)
		assert isinstance(name, str)
		self.alias = alias
		self.name = name
		UserDefinedTokenName.NameTab.append(self)


class Tab:
	semDeclPos = None  # Position,   position of global semantic declarations
	ignored = None  # Set,   characters ignored by the scanner
	ddt = [False] * 20  # boolean[20],  debug and test switches
	gramSy = None  # Symbol,   root nonterminal; filled by ATG
	eofSy = None  # Symbol,   end of file symbol
	noSym = None  # Symbol,   used in case of an error
	allSyncSets = None  # set,   union of all synchronisation sets
	nsName = ""  # namespace for generated files
	frameDir = None  # directory containing the frame files
	literals = {}  # Hashtable,   symbols that are used as literals

	visited = None  # set,   mark list for graph traversals
	curSy = None  # Symbol,   current symbol in computation of sets

	# ---------------------------------------------------------------------
	#  Symbol set computations
	# ---------------------------------------------------------------------

	@staticmethod
	def First0(p: Optional[Node], mark: Set[int]) -> Set[int]:
		"""Computes the first set for the given Node."""
		assert isinstance(p, Node) or (p is None)
		assert isinstance(mark, set)
		fs = set()
		while (p is not None) and not (p.n in mark):
			mark.add(p.n)
			if p.typ == NodeKind.nt:
				if p.sym.firstReady:
					fs |= p.sym.first
				else:
					fs |= Tab.First0(p.sym.graph, mark)
			elif p.typ in (NodeKind.t, NodeKind.wt):
				fs.add(p.sym.n)
			elif p.typ == NodeKind.any:
				fs |= p.set
			elif p.typ == NodeKind.alt:
				fs |= Tab.First0(p.sub, mark)
				fs |= Tab.First0(p.down, mark)
			elif p.typ in (NodeKind.iter, NodeKind.opt):
				fs |= Tab.First0(p.sub, mark)
			if not Node.DelNode(p):
				break
			p = p.next
		return fs

	@staticmethod
	def First(p: Optional[Node]) -> Set[int]:
		assert isinstance(p, Node) or (p is None)
		fs = Tab.First0(p, set())
		if Tab.ddt[3]:
			Trace.WriteLine()
			if p is not None:
				Trace.WriteLine("First: node = " + str(p.n))
			else:
				Trace.WriteLine("First: node = None")
			Tab.PrintSet(fs, 0)
		return fs

	@staticmethod
	def CompFirstSets() -> None:
		assert isinstance(Symbol.nonterminals, list)
		nt = Symbol.nonterminals
		for sym in nt:
			sym.first = set()
			sym.firstReady = False
		for sym in nt:
			sym.first = Tab.First(sym.graph)
			sym.firstReady = True

	@staticmethod
	def CompFollow(p: Optional[Node]) -> None:
		assert isinstance(p, Node) or (p is None)
		assert isinstance(Tab.visited, set)
		while (p is not None) and (p.n not in Tab.visited):
			Tab.visited.add(p.n)
			if p.typ == NodeKind.nt:
				s = Tab.First(p.next)
				p.sym.follow |= s
				if Node.DelGraph(p.next):
					p.sym.nts.add(Tab.curSy.n)
			elif p.typ == NodeKind.opt or p.typ == NodeKind.iter:
				Tab.CompFollow(p.sub)
			elif p.typ == NodeKind.alt:
				Tab.CompFollow(p.sub)
				Tab.CompFollow(p.down)
			p = p.next

	@staticmethod
	def Complete(sym: Symbol) -> None:
		assert isinstance(sym, Symbol)
		if sym.n not in Tab.visited:
			Tab.visited.add(sym.n)
			nt = Symbol.nonterminals
			for s in nt:
				if s.n in sym.nts:
					Tab.Complete(s)
					sym.follow |= s.follow
					if sym == Tab.curSy:
						sym.nts.discard(s.n)

	@staticmethod
	def CompFollowSets() -> None:
		nt = Symbol.nonterminals
		for sym in nt:
			sym.follow = set()
			sym.nts = set()
		Tab.gramSy.follow.add(Tab.eofSy.n)
		Tab.visited = set()
		for sym in nt:
			Tab.curSy = sym
			Tab.CompFollow(sym.graph)
		for sym in nt:
			Tab.visited = set()
			Tab.curSy = sym
			Tab.Complete(sym)

	@staticmethod
	def LeadingAny(p: Optional[Node]) -> Optional[Node]:
		assert isinstance(p, Node) or (p is None)
		if p is None:
			return None
		a = None
		if p.typ == NodeKind.any:
			a = p
		elif p.typ == NodeKind.alt:
			a = Tab.LeadingAny(p.sub)
			if a is None:
				a = Tab.LeadingAny(p.down)
		elif p.typ == NodeKind.opt or p.typ == NodeKind.iter:
			a = Tab.LeadingAny(p.sub)
		elif Node.DelNode(p) and not p.up:
			a = Tab.LeadingAny(p.next)
		return a

	@staticmethod
	def FindAS(p: Optional[Node]) -> None:
		"""find ANY sets"""
		assert isinstance(p, Node) or (p is None)
		while p is not None:
			if p.typ == NodeKind.opt or p.typ == NodeKind.iter:
				Tab.FindAS(p.sub)
				a = Tab.LeadingAny(p.sub)
				if a is not None:
					a.set -= Tab.First(p.next)
			elif p.typ == NodeKind.alt:
				s1 = set()
				q = p
				while q is not None:
					Tab.FindAS(q.sub)
					a = Tab.LeadingAny(q.sub)
					if a is not None:
						h = Tab.First(q.down)
						h |= s1
						a.set -= h
					else:
						s1 |= Tab.First(q.sub)
					q = q.down
			if p.up:
				break
			p = p.next

	@staticmethod
	def CompAnySets() -> None:
		nt = Symbol.nonterminals
		for sym in nt:
			Tab.FindAS(sym.graph)

	@staticmethod
	def Expected(p: Optional[Node], curSy: Symbol) -> Set[int]:
		assert isinstance(p, Node) or (p is None)
		assert isinstance(curSy, Symbol)
		s = Tab.First(p)
		if Node.DelGraph(p):
			s |= curSy.follow
		return s

	@staticmethod
	# does not look behind resolvers; only called during LL(1) test and in CheckRes
	def Expected0(p: Node, curSy: Symbol) -> Set[int]:
		assert isinstance(p, Node)
		assert isinstance(curSy, Symbol)
		if p.typ == NodeKind.rslv:
			return set()
		else:
			return Tab.Expected(p, curSy)

	@staticmethod
	def CompSync(p: Optional[Node]) -> None:
		assert isinstance(p, Node) or (p is None)
		while (p is not None) and (p.n not in Tab.visited):
			Tab.visited.add(p.n)
			if p.typ == NodeKind.sync:
				s = Tab.Expected(p.next, Tab.curSy)
				s.add(Tab.eofSy.n)
				Tab.allSyncSets |= s
				p.set = s
			elif p.typ == NodeKind.alt:
				Tab.CompSync(p.sub)
				Tab.CompSync(p.down)
			elif p.typ == NodeKind.opt or p.typ == NodeKind.iter:
				Tab.CompSync(p.sub)
			p = p.next

	@staticmethod
	def CompSyncSets() -> None:
		nt = Symbol.nonterminals
		Tab.allSyncSets = set()
		Tab.allSyncSets.add(Tab.eofSy.n)
		Tab.visited = set()
		for sym in nt:
			Tab.curSy = sym
			Tab.CompSync(Tab.curSy.graph)

	@staticmethod
	def SetupAnys() -> None:
		for p in Node.nodes:
			if p.typ == NodeKind.any:
				p.set = set()
				for j in range(0, len(Symbol.terminals)):
					p.set.add(j)
				p.set.discard(Tab.eofSy.n)

	@staticmethod
	def CompDeletableSymbols() -> None:
		nt = Symbol.nonterminals

		changed = False
		for sym in nt:
			if (not sym.deletable) and (sym.graph is not None) and Node.DelGraph(sym.graph):
				sym.deletable = True
				changed = True
		while changed:
			changed = False
			for sym in nt:
				if (not sym.deletable) and (sym.graph is not None) and Node.DelGraph(sym.graph):
					sym.deletable = True
					changed = True
		for sym in nt:
			if sym.deletable:
				print("  " + sym.name + " deletable")

	@staticmethod
	def RenumberPragmas() -> None:
		n = len(Symbol.terminals)
		for sym in Symbol.pragmas:
			sym.n = n
			n += 1

	@staticmethod
	def CompSymbolSets() -> None:
		Tab.CompDeletableSymbols()
		Tab.CompFirstSets()
		Tab.CompFollowSets()
		Tab.CompAnySets()
		Tab.CompSyncSets()
		if Tab.ddt[1]:
			Trace.WriteLine()
			Trace.WriteLine("First & follow symbols:")
			Trace.WriteLine("----------------------")
			Trace.WriteLine()
			nt = Symbol.nonterminals
			for sym in nt:
				Trace.WriteLine(sym.name)
				Trace.Write("first:   ")
				Tab.PrintSet(sym.first, 10)
				Trace.Write("follow:  ")
				Tab.PrintSet(sym.follow, 10)
				Trace.WriteLine()
		if Tab.ddt[4]:
			Trace.WriteLine()
			Trace.WriteLine("ANY and SYNC sets:")
			Trace.WriteLine("-----------------")
			for p in Node.nodes:
				if p.typ == NodeKind.any or p.typ == NodeKind.sync:
					Trace.Write(str(p.n), 4)
					Trace.Write(" ")
					Trace.Write(Node.nTyp[p.typ], 4)
					Trace.Write(": ")
					Tab.PrintSet(p.set, 12)
					Trace.WriteLine()

	# ---------------------------------------------------------------------
	#  Grammar checks
	# ---------------------------------------------------------------------

	@staticmethod
	def GrammarOk() -> bool:
		ok = Tab.NtsComplete() and Tab.AllNtReached() and Tab.NoCircularProductions() and Tab.AllNtToTerm() and Tab.ResolversOk()
		assert isinstance(ok, bool)
		if ok:
			Tab.CheckLL1()
		return ok

	# --------------- check for circular productions ----------------------

	@staticmethod
	def GetSingles(p: Optional[Node], singles: List[Symbol]) -> None:
		assert isinstance(p, Node) or (p is None)
		assert isinstance(singles, list)
		if p is None:
			return  # end of graph
		if p.typ == NodeKind.nt:
			if p.up or Node.DelGraph(p.next):
				singles.append(p.sym)
		elif p.typ == NodeKind.alt or p.typ == NodeKind.iter or p.typ == NodeKind.opt:
			if p.up or Node.DelGraph(p.next):
				Tab.GetSingles(p.sub, singles)
				if p.typ == NodeKind.alt:
					Tab.GetSingles(p.down, singles)
		if (not p.up) and Node.DelNode(p):
			Tab.GetSingles(p.next, singles)

	@staticmethod
	def NoCircularProductions() -> bool:
		class CNode(object):
			"""node of list for finding circular productions"""

			def __init__(self, l, r):
				self.left = l
				self.right = r

		lst = []
		for sym in Symbol.nonterminals:
			singles = []
			Tab.GetSingles(sym.graph, singles)  # get nonterminals s such that sym-->s
			for j in range(0, len(singles)):
				s = singles[j]
				lst.append(CNode(sym, s))

		changed = False
		i = 0
		while i < len(lst):
			n = lst[i]
			onLeftSide = False
			onRightSide = False
			for m in lst:
				if n.left == m.right:
					onRightSide = True
				if n.right == m.left:
					onLeftSide = True
			if (not onLeftSide) or (not onRightSide):
				lst.remove(n)
				i -= 1
				changed = True
			i += 1

		while changed:
			changed = False
			i = 0
			while i < len(lst):
				n = lst[i]
				onLeftSide = False
				onRightSide = False
				for m in lst:
					if n.left == m.right:
						onRightSide = True
					if n.right == m.left:
						onLeftSide = True
				if (not onLeftSide) or (not onRightSide):
					lst.remove(n)
					i -= 1
					changed = True
				i += 1

		ok = True
		for n in lst:
			ok = False
			Errors.count += 1
			print("  " + n.left.name + " --> " + n.right.name)
		return ok

	# --------------- check for LL(1) errors ----------------------

	@staticmethod
	def LL1Error(cond: int, sym: Optional[Symbol]) -> None:
		assert isinstance(cond, int)
		assert isinstance(sym, Symbol) or (sym is None)
		print("  LL(1) warning in " + Tab.curSy.name + ":", end=" ")
		if sym is not None:
			print(sym.name + " is", end=" ")
		if cond == 1:
			print("the start of several alternatives")
		elif cond == 2:
			print("the start & successor of a deletable structure")
		elif cond == 3:
			print("an ANY node that matches no symbol")
		elif cond == 4:
			print("contents of [...] or {...} must not be deletable")

	@staticmethod
	def CheckOverlap(s1: Set[int], s2: Set[int], cond: int) -> None:
		assert isinstance(s1, set)
		assert isinstance(s2, set)
		assert isinstance(cond, int)
		for sym in Symbol.terminals:
			if (sym.n in s1) and (sym.n in s2):
				Tab.LL1Error(cond, sym)

	@staticmethod
	def CheckAlts(p: Node) -> None:
		assert isinstance(p, Node)
		while p is not None:
			if p.typ == NodeKind.alt:
				q = p
				s1 = set()
				while q is not None:  # for all alternatives
					s2 = Tab.Expected0(q.sub, Tab.curSy)
					Tab.CheckOverlap(s1, s2, 1)
					s1 |= s2
					Tab.CheckAlts(q.sub)
					q = q.down
			elif p.typ == NodeKind.opt or p.typ == NodeKind.iter:
				if Node.DelSubGraph(p.sub):
					Tab.LL1Error(4, None)  # e.g. [[...]]
				else:
					s1 = Tab.Expected0(p.sub, Tab.curSy)
					s2 = Tab.Expected(p.next, Tab.curSy)
					Tab.CheckOverlap(s1, s2, 2)
				Tab.CheckAlts(p.sub)
			elif p.typ == NodeKind.any:
				if len(p.set) == 0:
					Tab.LL1Error(3, None)
				# e.g. {ANY} ANY or [ANY] ANY
			if p.up:
				break
			p = p.next

	@staticmethod
	def CheckLL1() -> None:
		for sym in Symbol.nonterminals:
			Tab.curSy = sym
			Tab.CheckAlts(Tab.curSy.graph)

	# ------------- check if resolvers are legal  --------------------

	resOk = False

	@staticmethod
	def ResErr(p: Node, msg: str) -> None:
		assert isinstance(p, Node)
		assert isinstance(msg, str)
		Errors.SemErr(msg, (p.line, p.pos.col))
		Tab.resOk = False

	@staticmethod
	def CheckRes(p: Node, rslvAllowed: bool) -> None:
		assert isinstance(p, Node)
		assert isinstance(rslvAllowed, bool)
		while p is not None:
			if p.typ == NodeKind.alt:
				expected = set()
				q = p
				while q is not None:
					expected |= Tab.Expected0(q.sub, Tab.curSy)
					q = q.down
				soFar = set()
				q = p
				while q is not None:
					if q.sub.typ == NodeKind.rslv:
						fs = Tab.Expected(q.sub.next, Tab.curSy)
						if fs.intersection(soFar):
							Tab.ResErr(q.sub, "Resolver will never be evaluated. " "Place it at previous conflicting alternative.")
						if not fs.intersection(expected):
							Tab.ResErr(q.sub, "Misplaced resolver: no LL(1) conflict.")
					else:
						soFar |= Tab.Expected(q.sub, Tab.curSy)
					Tab.CheckRes(q.sub, True)

					q = q.down
			elif p.typ in (NodeKind.iter, NodeKind.opt):
				if p.sub.typ == NodeKind.rslv:
					fs = Tab.First(p.sub.next)
					fsNext = Tab.Expected(p.next, Tab.curSy)
					if not fs.intersection(fsNext):
						Tab.ResErr(p.sub, "Misplaced resolver: no LL(1) conflict.")
				Tab.CheckRes(p.sub, True)
			elif p.typ == NodeKind.rslv:
				if not rslvAllowed:
					Tab.ResErr(p, "Misplaced resolver: no alternative.")
			if p.up:
				break
			p = p.next
			rslvAllowed = False

	@staticmethod
	def ResolversOk() -> bool:
		Tab.resOk = True
		for sym in Symbol.nonterminals:
			Tab.curSy = sym
			Tab.CheckRes(Tab.curSy.graph, False)
		return Tab.resOk

	# ------------- check if every nts has a production --------------------

	@staticmethod
	def NtsComplete() -> bool:
		complete = True
		for sym in Symbol.nonterminals:
			if sym.graph is None:
				complete = False
				Errors.count += 1
				print("  No production for " + sym.name)
		return complete

	# -------------- check if every nts can be reached  -----------------

	@staticmethod
	def MarkReachedNts(p: Optional[Node]) -> None:
		assert isinstance(p, Node) or (p is None)
		while p is not None:
			if p.typ == NodeKind.nt and (p.sym.n not in Tab.visited):  # new nt reached
				Tab.visited.add(p.sym.n)
				Tab.MarkReachedNts(p.sym.graph)
			elif p.typ == NodeKind.alt or p.typ == NodeKind.iter or p.typ == NodeKind.opt:
				Tab.MarkReachedNts(p.sub)
				if p.typ == NodeKind.alt:
					Tab.MarkReachedNts(p.down)
			if p.up:
				break
			p = p.next

	@staticmethod
	def AllNtReached() -> bool:
		ok = True
		Tab.visited = set()
		Tab.visited.add(Tab.gramSy.n)
		Tab.MarkReachedNts(Tab.gramSy.graph)
		for sym in Symbol.nonterminals:
			if sym.n not in Tab.visited:
				ok = False
				Errors.count += 1
				print("  " + sym.name + " cannot be reached")
		return ok

	# --------- check if every nts can be derived to terminals  ------------

	@staticmethod
	def IsTerm(p: Node, mark: Set[int]) -> bool:
		"""true if graph can be derived to terminals"""
		assert isinstance(p, Node)
		assert isinstance(mark, set)
		while p is not None:
			if p.typ == NodeKind.nt and (p.sym.n not in mark):
				return False
			if p.typ == NodeKind.alt and not Tab.IsTerm(p.sub, mark) and ((p.down is None) or not Tab.IsTerm(p.down, mark)):
				return False
			if p.up:
				break
			p = p.next
		return True

	@staticmethod
	def AllNtToTerm() -> bool:
		ok = True
		mark = set()
		# a nonterminal is marked if it can be derived to terminal symbols

		changed = False
		for sym in Symbol.nonterminals:
			if (sym.n not in mark) and Tab.IsTerm(sym.graph, mark):
				mark.add(sym.n)
				changed = True

		while changed:
			changed = False
			for sym in Symbol.nonterminals:
				if (sym.n not in mark) and Tab.IsTerm(sym.graph, mark):
					mark.add(sym.n)
					changed = True

		for sym in Symbol.nonterminals:
			if sym.n not in mark:
				ok = False
				Errors.count += 1
				print("  " + sym.name + " cannot be derived to terminals")
		return ok

	# ---------------------------------------------------------------------
	#  Utility functions
	# ---------------------------------------------------------------------

	@staticmethod
	def Num(p):
		if p is None:
			return 0
		else:
			return p.n

	@staticmethod
	def PrintSet(aSet, indent):
		assert isinstance(indent, int)

		col = indent

		for sym in Symbol.terminals:
			if sym.n in aSet:
				ln = len(sym.name)
				if col + ln >= 80:
					Trace.WriteLine()
					col = 1
					while col < indent:
						Trace.Write(" ")
						col += 1
				Trace.Write(sym.name + " ")
				col += ln + 1
		if col == indent:
			Trace.Write("-- empty set --")
		Trace.WriteLine()

	tKind = ["fixedToken   ", "classToken   ", "litToken     ", "classLitToken"]

	@staticmethod
	def PrintSym(sym):
		assert isinstance(sym, Symbol)
		Trace.Write(str(sym.n), 3)
		Trace.Write(" ")
		Trace.Write(Node.Name(sym.name), -14)
		Trace.Write(" ")
		Trace.Write(Node.nTyp[sym.typ], 2)
		if sym.attrPos is None:
			Trace.Write(" false ")
		else:
			Trace.Write(" true  ")
		if sym.typ == NodeKind.nt:
			Trace.Write(str(Tab.Num(sym.graph)), 5)
			if sym.deletable:
				Trace.Write(" true  ")
			else:
				Trace.Write(" false ")
		else:
			Trace.Write(INDENT * 4 + "")
		Trace.Write(str(sym.line), 5)
		Trace.Write(" " + Tab.tKind[sym.tokenKind].strip())
		if (sym.typ == NodeKind.pr or sym.typ == NodeKind.t) and (sym.symName is not None):
			Trace.Write(INDENT + sym.symName)
		Trace.WriteLine()

	@staticmethod
	def PrintSymbolTable():
		Trace.WriteLine("Symbol Table:")
		Trace.WriteLine("------------")
		Trace.WriteLine()
		Trace.WriteLine(" nr name          typ  hasAt graph  del    line tokenKind")
		for sym in Symbol.terminals:
			Tab.PrintSym(sym)
		for sym in Symbol.pragmas:
			Tab.PrintSym(sym)
		for sym in Symbol.nonterminals:
			Tab.PrintSym(sym)
		Trace.WriteLine()
		Trace.WriteLine("Literal Tokens:")
		Trace.WriteLine("--------------")
		for me_key, me_value in sorted(Tab.literals.items()):
			Trace.WriteLine("_" + me_value.name + " = " + me_key + ".")
		Trace.WriteLine()

	@staticmethod
	def XRef():
		tab = {}
		for sym in Symbol.nonterminals:
			if sym in tab:
				lst = tab[sym]
			else:
				lst = []
				tab[sym] = lst
			lst.append(-sym.line)

		# collect lines where symbols have been referenced
		for n in Node.nodes:
			if n.typ in (NodeKind.t, NodeKind.wt, NodeKind.nt):
				if n.sym in tab:
					lst = tab[n.sym]
				else:
					lst = []
					tab[n.sym] = lst
				lst.append(n.line)

		# print cross reference list
		Trace.WriteLine("Cross reference list:")
		Trace.WriteLine("--------------------")
		Trace.WriteLine()
		keyList = [x.name for x in list(tab.keys())]
		keyList.sort()
		for key in keyList:
			for k in list(tab.keys()):
				if k.name == key:
					sym = k
					break

			Trace.Write("  ")
			Trace.Write(Node.Name(sym.name), -12)
			lst = tab[sym]
			col = 14
			for line in lst:
				if col + 5 > 80:
					Trace.WriteLine()
					for col in range(1, 15):
						Trace.Write(" ")
				Trace.Write(str(line), 5)
				col += 5
			Trace.WriteLine()
		Trace.WriteLine()
		Trace.WriteLine()

	@staticmethod
	def SetDDT(s):
		options = {"traceAutomaton": 0, "generateDriver": 11, "firstAndFollow": 1, "syntaxGraph": 2, "traceComputations": 3, "listAnyAndSync": 4, "mergeErrors": 5, "tokenNames": 10, "statistics": 8, "symbolTable": 6, "testOnly": 9, "crossReferences": 7}
		for key, code in options.items():
			if getattr(s, key):
				Tab.ddt[code] = True

	def __init__(self) -> None:
		Tab.eofSy = Symbol(NodeKind.t, "EOF", 0)
		Tab.literals = {}

	# considerable extension from here on to handle name generation

	@staticmethod
	def NewName(alias, name):
		assert isinstance(alias, str)
		assert isinstance(name, str)
		if name.find(" ") >= 0:
			Errors.SemErr("tokens must not contain blanks")
		u = UserDefinedTokenName(alias, name)

	@staticmethod
	def Ascii(ch):
		assert isinstance(ch, str)
		name = {chr(0): "nul", chr(1): "soh", chr(2): "stx", chr(3): "etx", chr(4): "eot", chr(5): "enq", chr(6): "ack", chr(7): "bel", chr(8): "bs", chr(9): "ht", chr(10): "lf", chr(11): "vt", chr(12): "ff", chr(13): "cr", chr(14): "so", chr(15): "si", chr(16): "dle", chr(17): "dc1", chr(18): "dc2", chr(19): "dc3", chr(20): "dc4", chr(21): "nak", chr(22): "syn", chr(23): "etb", chr(24): "can", chr(25): "em", chr(26): "sub", chr(27): "esc", chr(28): "fs", chr(29): "gs", chr(30): "rs", chr(31): "us", " ": "_", "!": "bang", '"': "dquote", "#": "hash", "$": "dollar", "%": "percent", "&": "and", "'": "squote", "(": "lparen", ")": "rparen", "*": "star", "+": "plus", ",": "comma", "-": "minus", ".": "point", "/": "slash", "0": "d0", "1": "d1", "2": "d2", "3": "d3", "4": "d4", "5": "d5", "6": "d6", "7": "d7", "8": "d8", "9": "d9", ":": "colon", ";": "semicolon", "<": "less", "=": "equal", ">": "greater", "?": "query", "@": "at", "[": "lbrack", "\\": "backslash", "]": "rbrack", "^": "uparrow", "_": "underscore", "`": "accent", "{": "lbrace", "|": "bar", "}": "rbrace", "~": "tilde", chr(127): "delete"}
		if ch in name:
			return name[ch]
		else:
			return "ASC" + str(ch)

	@staticmethod
	def SymName(name):
		assert isinstance(name, str)
		name = str(name)
		for u in UserDefinedTokenName.NameTab:
			if name == u.name:
				return u.alias
		if name[0] == '"':
			name = DFA.Unescape(name[1:-1])
		S = ""
		for i in range(0, len(name)):
			ch = name[i]
			if "a" <= ch <= "z" or "A" <= ch <= "Z" or "0" <= ch <= "9" and i > 0:
				S += ch
			else:
				S += Tab.Ascii(ch)
		S += "_Sym"
		return S

	@staticmethod
	def AssignNames():
		for sym in Symbol.terminals:
			sym.symName = Tab.SymName(sym.name)
		for sym in Symbol.pragmas:
			sym.symName = Tab.SymName(sym.name)
		Symbol.terminals[0].symName = "EOF_SYM"
		Symbol.terminals[len(Symbol.terminals) - 1].symName = "NOT_SYM"
		sys.stdout.write(" (Names assigned)")


class DFA(object):
	maxStates = 0
	EOF = -1
	CR = "\r"
	LF = "\n"

	firstState = None  # State
	lastState = None  # State,  last allocated state
	lastSimState = 0  # last non melted state
	fram = None  # Reader, scanner frame input
	gen = None  # PrintWriter,  generated scanner file
	curSy = None  # Symbol, current token to be recognized (in FindTrans)
	curGraph = None  # Node, start of graph for current token (in FindTrans)
	ignoreCase = False  # true if input should be treated case-insensitively
	dirtyDFA = False  # DFA may become nondeterministic in MatchedDFA
	hasCtxMoves = False  # DFA has context transitions
	srcName = ""  # name of the attributed grammar file
	srcDir = ""  # directory of attributed grammar file
	outDir = ""  # directory to put output

	def framRead(self) -> str:
		try:
			return self.fram.read(1)
		except BaseException:
			raise RuntimeError("-- error reading Scanner.frame")
		return self.EOF

		# ---------- Output primitives

	def Ch(self, ch):
		if isinstance(ch, int):
			ch = str(ch)
		if ch < " " or ch >= str(127) or ch == "'" or ch == "\\":
			return ch
		else:
			return "ord('" + ch + "')"
		# if isinstance(ch, (str,unicode)):
		# ch = ord(ch)
		# if (ch < ord(' ') or ch >= 127 or ch == ord('\'') or ch == ord('\\')):
		# return str(ch)
		# else:
		# return "ord('" + chr(ch) + "')"

	def ReportCh(self, ch):
		if isinstance(ch, str):
			ch = ord(ch)
		if ch < ord(" ") or ch >= 127 or ch == ord("'") or ch == ord("\\"):
			return str(ch)
		else:
			return "".join(["'", chr(ch), "'"])

	def ChCond(self, ch: Union[int, str], relOpStr: str = "==") -> str:
		if isinstance(ch, str):
			ch = ord(ch)

		if ch < ord(" ") or ch >= 127 or ch == ord("'") or ch == ord("\\"):
			return "".join(["ord(self.ch) ", relOpStr, " ", str(ch)])
		else:
			return "".join(["self.ch ", relOpStr, " '", chr(ch), "'"])

	def PutRange(self, s: Union[Set[int], Set[Union[int, str]]]) -> None:
		assert isinstance(s, set)
		lo = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
		hi = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
		# fill lo and hi
		mx = CharClass.charSetSize
		top = -1
		i = 0
		while i < mx:
			if i in s:
				top += 1
				lo[top] = i
				i += 1
				while i < mx and (i in s):
					i += 1
				hi[top] = i - 1
			else:
				i += 1
		# print ranges
		if top == 1 and lo[0] == 0 and hi[1] == mx - 1 and hi[0] + 2 == lo[1]:
			s1 = set()
			s1.add(hi[0] + 1)
			self.gen.write("not ")
			self.PutRange(s1)
			self.gen.write(" and Scanner.ch != Scanner.buffer.EOF")
		else:
			self.gen.write("(")

			for i in range(0, top + 1):
				if hi[i] == lo[i]:
					self.gen.write(self.ChCond(lo[i]))
				elif lo[i] == 0:
					self.gen.write(self.ChCond(hi[i], "<="))
				else:
					self.gen.write(self.ChCond(lo[i], ">="))
					self.gen.write(" and " + self.ChCond(hi[i], "<="))
				if i < top:
					self.gen.write("\n")
					self.gen.write(INDENT * 5 + "  or ")
			if "ANYCHAR" in s:
				self.gen.write(" or ord(self.ch) > %d" % CharClass.charSetSize)
			self.gen.write(")")

		# ---------- String handling

	@staticmethod
	def Hex2Char(s: str) -> str:
		assert isinstance(s, str)
		val = 0  # int
		for i in range(0, len(s)):
			ch = s[i]  # char
			if "0" <= ch <= "9":
				val = 16 * val + (ord(ch) - ord("0"))
			elif "a" <= ch <= "f":
				val = 16 * val + (10 + ord(ch) - ord("a"))
			elif "A" <= ch <= "F":
				val = 16 * val + (10 + ord(ch) - ord("A"))
			else:
				Errors.SemErr("bad escape sequence in string or character")
		if val > CharClass.charSetSize:
			Errors.SemErr("bad escape sequence in string or character")
		return chr(val % CharClass.charSetSize)

	@staticmethod
	def Char2Hex(ch):
		assert isinstance(ch, str)
		hx = hex(ord(ch))
		for i in range(len(hx), 4):
			hx = "0" + hx
		return "\\u" + hx

	def Unescape(self, s: str) -> str:
		# replaces escape sequences in s by their Unicode values.
		assert isinstance(s, str)
		buf = ""
		i = 0
		while i < len(s):
			if s[i] == "\\":
				ch = s[i + 1]
				if ch in ("u", "x"):
					if i + 4 <= len(s):
						buf += self.Hex2Char(s[i + 2 : i + 6])
						i += 6
					else:
						Errors.SemErr("bad escape sequence in string or character")
						i = len(s)
				elif ch in ("\\", "'", '"', "r", "n", "t", "0", "a", "b", "f"):
					buf += {"\\": "\\", "'": "'", '"': '"', "r": "\r", "n": "\n", "t": "\t", "0": "\0", "a": "\a", "b": "\b", "f": "\f"}[s[i + 1]]
					i += 2
				else:
					Errors.SemErr("bad escape sequence in string or character")
					i += 2
			else:
				buf += s[i]
				i += 1
		return buf

	@staticmethod
	def Escape(s: str) -> str:
		assert isinstance(s, str)
		buf = ""
		for ch in s:
			if ch in ("\\", "'", '"', "\t", "\r", "\n"):
				buf += {"\\": "\\\\", "'": "\\'", '"': '\\"', "\t": "\\t", "\r": "\\r", "\n": "\\n"}[ch]
			elif ch < " " or ch > chr(127):  # '\x7f'
				buf += self.Char2Hex(ch)
			else:
				buf += ch
		return buf

	# ---------- State handling
	def NewState(self) -> State:
		s = State(dfa=self)  # State
		if self.firstState is None:
			self.firstState = s
		else:
			self.lastState.next = s
		self.lastState = s
		return s

	def NewTransition(self, frm: State, to: State, typ: int, sym: Union[int, str], tc: int) -> None:
		assert isinstance(frm, State)
		assert isinstance(to, State)
		assert isinstance(typ, int)
		assert isinstance(sym, (int, str))
		assert isinstance(tc, int)
		if to == self.firstState:
			Errors.SemErr("token must not start with an iteration")
		if isinstance(sym, str):
			sym = ord(sym)
		t = Target(to)
		a = Action(typ, sym, tc, dfa=self)
		a.target = t
		frm.AddAction(a)
		if typ == NodeKind.clas:
			self.curSy.tokenKind = Symbol.classToken

	def CombineShifts(self) -> None:
		state = self.firstState
		while state is not None:
			a = state.firstAction
			while a is not None:
				b = a.next
				while b is not None:
					if a.target.state == b.target.state and a.tc == b.tc:
						seta = a.Symbols()
						setb = b.Symbols()
						seta |= setb
						a.ShiftWith(seta)
						c = b
						b = b.next
						state.DetachAction(c)
					else:
						b = b.next
				a = a.next
			state = state.next

	def FindUsedStates(self, state: State, used: Set[int]) -> None:
		assert isinstance(state, State)
		assert isinstance(used, set)
		if state.nr in used:
			return
		used.add(state.nr)
		a = state.firstAction
		while a is not None:
			self.FindUsedStates(a.target.state, used)
			a = a.next

	def DeleteRedundantStates(self) -> None:
		newState = [None for x in range(State.lastNr + 1)]
		used = set()
		self.FindUsedStates(self.firstState, used)
		# combine equal final states
		s1 = self.firstState.next
		while s1 is not None:
			# self.firstState cannot be final
			if (s1.nr in used) and (s1.endOf is not None) and (s1.firstAction is None) and not s1.ctx:
				s2 = s1.next
				while s2 is not None:
					nots2_ctx = 1 if not s2.ctx else 0
					if (s2.nr in used) and s1.endOf == s2.endOf and (s2.firstAction is None) & nots2_ctx:
						used.discard(s2.nr)
						newState[s2.nr] = s1
					s2 = s2.next
			s1 = s1.next

		state = self.firstState
		while state is not None:
			if state.nr in used:
				a = state.firstAction
				while a is not None:
					if a.target.state.nr not in used:
						a.target.state = newState[a.target.state.nr]
					a = a.next
			state = state.next

		# delete unused states
		self.lastState = self.firstState
		State.lastNr = 0  # self.firstState has number 0
		state = self.firstState.next
		while state is not None:
			if state.nr in used:
				State.lastNr += 1
				state.nr = State.lastNr
				self.lastState = state
			else:
				self.lastState.next = state.next
			state = state.next

	def TheState(self, p: Optional[Node]) -> State:
		assert isinstance(p, Node) or (p is None)
		if p is None:
			state = self.NewState()
			state.endOf = self.curSy
			return state
		else:
			return p.state

	def Step(self, frm: State, p: Optional[Node], stepped: Set[int]) -> None:
		assert isinstance(frm, State)
		assert isinstance(p, Node) or (p is None)
		assert isinstance(stepped, set)
		if p is None:
			return
		stepped.add(p.n)
		if p.typ in (NodeKind.clas, NodeKind.chr):
			self.NewTransition(frm, self.TheState(p.next), p.typ, p.val, p.code)
		elif p.typ == NodeKind.alt:
			self.Step(frm, p.sub, stepped, trace)
			self.Step(frm, p.down, stepped, trace)
		elif p.typ in (NodeKind.iter, NodeKind.opt):
			if (p.next is not None) and (p.next.n not in stepped):
				self.Step(frm, p.next, stepped, trace)
			self.Step(frm, p.sub, stepped)

	def NumberNodes(self, p: Optional[Node], state: Optional[State]) -> None:
		"""Assigns a state n.state to every node n. There will be a transition
        from n.state to n.next.state triggered by n.val. All nodes in an
        alternative chain are represented by the same state."""
		assert isinstance(p, Node) or (p is None)
		assert isinstance(state, State) or (state is None)
		if p is None:
			return
		if p.state is not None:
			return
		if state is None:
			state = self.NewState()
		p.state = state
		if Node.DelGraph(p):
			state.endOf = self.curSy
		if p.typ in (NodeKind.clas, NodeKind.chr):
			self.NumberNodes(p.next, None)
		elif p.typ == NodeKind.opt:
			self.NumberNodes(p.next, None)
			self.NumberNodes(p.sub, state)
		elif p.typ == NodeKind.iter:
			self.NumberNodes(p.next, state)
			self.NumberNodes(p.sub, state)
		elif p.typ == NodeKind.alt:
			self.NumberNodes(p.sub, state)
			self.NumberNodes(p.down, state)

	def FindTrans(self, p: Optional[Node], start: bool, marked: Set[int]) -> None:
		assert isinstance(p, Node) or (p is None)
		assert isinstance(start, bool)
		assert isinstance(marked, set)
		if (p is None) or (p.n in marked):
			return
		marked.add(p.n)
		if start:
			self.Step(p.state, p, set())  # / start of group of equally numbered nodes
		if p.typ in (NodeKind.clas, NodeKind.chr):
			self.FindTrans(p.next, True, marked)
		elif p.typ == NodeKind.opt:
			self.FindTrans(p.next, True, marked)
			self.FindTrans(p.sub, False, marked)
		elif p.typ == NodeKind.iter:
			self.FindTrans(p.next, False, marked)
			self.FindTrans(p.sub, False, marked)
		elif p.typ == NodeKind.alt:
			self.FindTrans(p.sub, False, marked)
			self.FindTrans(p.down, False, marked)

	def ConvertToStates(self, p: Node, sym: Symbol) -> None:
		assert isinstance(p, Node), repr(p)
		assert isinstance(sym, Symbol)
		self.curGraph = p
		self.curSy = sym
		if Node.DelGraph(self.curGraph):
			Errors.SemErr("token might be empty")
		self.NumberNodes(self.curGraph, self.firstState)
		self.FindTrans(self.curGraph, True, set())

	def MatchLiteral(self, s: str, sym: Symbol) -> None:
		assert isinstance(sym, Symbol)
		assert isinstance(s, str)
		"""match string against current automaton; store it either as a
      fixedToken or as a litToken"""
		s = self.Unescape(s[1:-1])
		ln = len(s)
		state = self.firstState  # State
		a = None
		endedPrematurely = False
		for i in range(0, ln):  # try to match s against existing DFA
			a = state.TheAction(s[i])
			if a is None:
				endedPrematurely = True
				break
			state = a.target.state
		if not endedPrematurely:
			i = ln
		# if s was not totally consumed or leads to a non-final state => make new DFA from it
		if (i != ln) or (state.endOf is None):
			state = self.firstState
			i = 0
			a = None
			self.dirtyDFA = True
		while i < ln:  # make new DFA for s[i..len-1]
			to = self.NewState()  # State
			self.NewTransition(state, to, NodeKind.chr, s[i], Node.normalTrans)
			state = to
			i += 1
		matchedSym = state.endOf  # Symbol
		if state.endOf is None:
			state.endOf = sym
		elif (matchedSym.tokenKind == Symbol.fixedToken) or (a is not None) and (a.tc == Node.contextTrans):
			# s matched a token with a fixed definition or a token with an appendix that will be cut off
			Errors.SemErr("tokens " + sym.name + " and " + matchedSym.name + " cannot be distinguished")
		else:
			# matchedSym == classToken or classLitToken
			matchedSym.tokenKind = Symbol.classLitToken
			sym.tokenKind = Symbol.litToken

	def SplitActions(self, state: State, a: Action, b: Action) -> None:
		assert isinstance(state, State)
		assert isinstance(a, Action)
		assert isinstance(b, Action)
		seta = a.Symbols()
		setb = b.Symbols()
		if seta == setb:  # seta.equals(setb):
			a.AddTargets(b)
			state.DetachAction(b)
		elif seta >= setb:
			setc = copy.copy(seta)
			setc -= setb
			b.AddTargets(a)
			a.ShiftWith(setc)
		elif setb >= seta:
			setc = copy.copy(setb)
			setc -= seta
			a.AddTargets(b)
			b.ShiftWith(setc)
		else:
			setc = copy.copy(seta)
			setc &= setb
			seta -= setc
			setb -= setc
			a.ShiftWith(seta)
			b.ShiftWith(setb)
			c = Action(0, 0, Node.normalTrans, self)  # typ and sym are set in ShiftWith
			c.AddTargets(a)
			c.AddTargets(b)
			c.ShiftWith(setc)
			state.AddAction(c)

	@staticmethod
	def Overlap(a: Action, b: Action) -> bool:
		assert isinstance(a, Action)
		assert isinstance(b, Action)
		if a.typ == NodeKind.chr:
			if b.typ == NodeKind.chr:
				return a.sym == b.sym
			else:
				setb = CharClass.Set(b.sym)
				return a.sym in setb
		else:
			seta = CharClass.Set(a.sym)
			if b.typ == NodeKind.chr:
				return b.sym in seta
			else:
				setb = CharClass.Set(b.sym)
				return len(seta & setb) > 0
				# return seta.intersects( setb )

	def MakeUnique(self, state: State) -> bool:
		assert isinstance(state, State)
		# return True if actions were split
		changed = False  # boolean
		a = state.firstAction
		while a is not None:
			b = a.next
			while b is not None:
				if self.Overlap(a, b):
					self.SplitActions(state, a, b)
					changed = True
				b = b.next
			a = a.next
		return changed

	def MeltStates(self, state: State) -> None:
		assert isinstance(state, State)
		action = state.firstAction
		while action is not None:
			if action.target.next is not None:
				param = [None, None]
				ctx = action.GetTargetStates(param)
				targets = param[0]
				endOf = param[1]
				melt = Melted.StateWithSet(targets)  # Melted
				if melt is None:
					s = self.NewState()
					s.endOf = endOf
					s.ctx = ctx
					targ = action.target
					while targ is not None:
						s.MeltWith(targ.state)
						targ = targ.next
					changed = self.MakeUnique(s)
					while changed:
						changed = self.MakeUnique(s)
					melt = Melted(targets, s)
				action.target.next = None
				action.target.state = melt.state
			action = action.next

	def FindCtxStates(self) -> None:
		state = self.firstState
		while state is not None:
			a = state.firstAction
			while a is not None:
				if a.tc == Node.contextTrans:
					a.target.state.ctx = True
				a = a.next
			state = state.next

	def MakeDeterministic(self) -> None:
		self.lastSimState = self.lastState.nr
		self.maxStates = 2 * self.lastSimState  # heuristic for set size in Melted.set
		self.FindCtxStates()
		state = self.firstState
		while state is not None:
			changed = self.MakeUnique(state)
			while changed:
				changed = self.MakeUnique(state)
			state = state.next

		state = self.firstState
		while state is not None:
			self.MeltStates(state)
			state = state.next
		self.DeleteRedundantStates()
		self.CombineShifts()

	def PrintStates(self):
		Trace.WriteLine()
		Trace.WriteLine("Automaton Trace:")
		Trace.WriteLine("---------------")
		Trace.WriteLine()
		Trace.WriteLine("---------- states ----------")
		state = self.firstState
		while state is not None:
			first = True  # boolean
			if state.endOf is None:
				Trace.Write(INDENT * 5)
			else:
				Trace.Write("E(" + Node.Name(state.endOf.name) + ")", 12)
			Trace.Write(str(state.nr) + ":", 4)
			if state.firstAction is None:
				Trace.WriteLine()
			action = state.firstAction
			while action is not None:
				if first:
					Trace.Write(" ")
					first = False
				else:
					Trace.Write(INDENT * 6 + "  ")
				if action.typ == NodeKind.clas:
					Trace.Write(CharClass.classes[action.sym].name)
				else:
					Trace.Write(self.ReportCh(action.sym), 3)
				targ = action.target
				while targ is not None:
					Trace.Write(str(targ.state.nr), 4)
					targ = targ.next
				if action.tc == Node.contextTrans:
					Trace.WriteLine(" context")
				else:
					Trace.WriteLine()
				action = action.next
			state = state.next
		Trace.WriteLine()
		Trace.WriteLine("---------- character classes ----------")
		CharClass.WriteClasses()

	def GenComBody2(self, com: Comment) -> None:
		assert isinstance(com, Comment)
		self.gen.write(INDENT * 2 + "while True:\n")
		self.gen.write(INDENT * 3 + "if " + self.ChCond(com.stop[0]) + ":\n")
		if len(com.stop) == 1:
			self.gen.write(INDENT * 4 + "level -= 1\n")
			self.gen.write(INDENT * 4 + "if level == 0:\n")
			self.gen.write(INDENT * 5 + "self.oldEols = self.line - line0\n")
			self.gen.write(INDENT * 5 + "self.NextCh()\n")
			self.gen.write(INDENT * 5 + "return True\n")
			self.gen.write(INDENT * 4 + "self.NextCh()\n")
		else:
			self.gen.write(INDENT * 4 + "self.NextCh()\n")
			self.gen.write(INDENT * 4 + "if " + self.ChCond(com.stop[1]) + ":\n")
			self.gen.write(INDENT * 5 + "level -= 1\n")
			self.gen.write(INDENT * 5 + "if level == 0:\n")
			self.gen.write(INDENT * 6 + "self.oldEols = self.line - line0\n")
			self.gen.write(INDENT * 6 + "self.NextCh()\n")
			self.gen.write(INDENT * 6 + "return True\n")
			self.gen.write(INDENT * 5 + "self.NextCh()\n")
		if com.nested:
			self.gen.write(INDENT * 3 + "elif " + self.ChCond(com.start[0]) + ":\n")
			if len(com.start) == 1:
				self.gen.write(INDENT * 4 + "level += 1\n")
				self.gen.write(INDENT * 4 + "self.NextCh()\n")
			else:
				self.gen.write(INDENT * 4 + "self.NextCh()\n")
				self.gen.write(INDENT * 4 + "if " + self.ChCond(com.start[1]) + ":\n")
				self.gen.write(INDENT * 5 + "level += 1\n")
				self.gen.write(INDENT * 5 + "self.NextCh()\n")
		self.gen.write(INDENT * 3 + "elif self.ch == Buffer.EOF:\n")
		self.gen.write(INDENT * 4 + "return False\n")
		self.gen.write(INDENT * 3 + "else:\n")
		self.gen.write(INDENT * 4 + "self.NextCh()\n")

	def GenComBody3(self, com: Comment) -> None:
		assert isinstance(com, Comment)
		self.gen.write(INDENT * 3 + "while True:\n")
		self.gen.write(INDENT * 4 + "if " + self.ChCond(com.stop[0]) + ":\n")
		if len(com.stop) == 1:
			self.gen.write(INDENT * 5 + "level -= 1\n")
			self.gen.write(INDENT * 5 + "if level == 0:\n")
			self.gen.write(INDENT * 6 + "self.oldEols = self.line - line0\n")
			self.gen.write(INDENT * 6 + "self.NextCh()\n")
			self.gen.write(INDENT * 6 + "return True\n")
			self.gen.write(INDENT * 5 + "self.NextCh()\n")
		else:
			self.gen.write(INDENT * 5 + "self.NextCh()\n")
			self.gen.write(INDENT * 5 + "if " + self.ChCond(com.stop[1]) + ":\n")
			self.gen.write(INDENT * 6 + "level -= 1\n")
			self.gen.write(INDENT * 6 + "if level == 0:\n")
			self.gen.write(INDENT * 6 * 2 + "self.oldEols = self.line - line0\n")
			self.gen.write(INDENT * 6 * 2 + "self.NextCh()\n")
			self.gen.write(INDENT * 6 * 2 + "return True\n")
			self.gen.write(INDENT * 6 + "self.NextCh()\n")
		if com.nested:
			self.gen.write(INDENT * 4 + "elif " + self.ChCond(com.start[0]) + ":\n")
			if len(com.start) == 1:
				self.gen.write(INDENT * 5 + "level += 1")
				self.gen.write(INDENT * 5 + "self.NextCh()")
			else:
				self.gen.write(INDENT * 5 + "self.NextCh()\n")
				self.gen.write(INDENT * 5 + "if " + self.ChCond(com.start[1]) + ":\n")
				self.gen.write(INDENT * 6 + "level += 1\n")
				self.gen.write(INDENT * 6 + "self.NextCh()\n")
		self.gen.write(INDENT * 4 + "elif self.ch == Buffer.EOF:\n")
		self.gen.write(INDENT * 5 + "return False\n")
		self.gen.write(INDENT * 4 + "else:\n")
		self.gen.write(INDENT * 5 + "self.NextCh()\n")

	def GenComment(self, com: Comment, i: int) -> None:
		assert isinstance(com, Comment)
		assert isinstance(i, int)
		self.gen.write("\n")
		self.gen.write(INDENT + "def Comment" + str(i) + "( self ):\n")
		self.gen.write(INDENT * 2 + "level = 1\n")
		self.gen.write(INDENT * 2 + "line0 = self.line\n")
		self.gen.write(INDENT * 2 + "lineStart0 = self.lineStart\n")
		if len(com.start) == 1:
			self.gen.write(INDENT * 2 + "self.NextCh()\n")
			self.GenComBody2(com)
		else:
			self.gen.write(INDENT * 2 + "self.NextCh()\n")
			self.gen.write(INDENT * 2 + "if " + self.ChCond(com.start[1]) + ":\n")
			self.gen.write(INDENT * 3 + "self.NextCh()\n")
			self.GenComBody3(com)
			self.gen.write(INDENT * 2 + "else:\n")
			self.gen.write(INDENT * 3 + "if self.ch == Scanner.EOL:\n")
			self.gen.write(INDENT * 4 + "self.line -= 1\n")
			self.gen.write(INDENT * 4 + "self.lineStart = lineStart0\n")
			self.gen.write(INDENT * 3 + "self.pos = self.pos - 2\n")
			self.gen.write(INDENT * 3 + "self.buffer.setPos(self.pos+1)\n")
			self.gen.write(INDENT * 3 + "self.NextCh()\n")
			self.gen.write(INDENT * 2 + "return False\n")

	def CopyFramePart(self, stop: str) -> None:
		assert isinstance(stop, str)
		last = 0  # int
		startCh = stop[0]
		endOfStopString = len(stop) - 1
		ch = self.framRead()  # int

		while ch != self.EOF:
			if ch == startCh:
				i = 0
				if i == endOfStopString:
					return  # stop[0..i] found
				ch = self.framRead()
				i += 1
				while ch == stop[i]:
					if i == endOfStopString:
						return  # stop[0..i] found
					ch = self.framRead()
					i += 1
				# stop
				self.gen.write(stop[0:1])
			elif ch == self.LF:
				if last != self.CR:
					self.gen.write("\n")
				last = ch
				ch = self.framRead()
			elif ch == self.CR:
				self.gen.write("\n")
				last = ch
				ch = self.framRead()
			else:
				if isinstance(chr, int):
					self.gen.write(chr(ch))
				else:
					self.gen.write(ch)
				last = ch
				ch = self.framRead()
		raise RuntimeError(" -- incomplete or corrupt scanner frame file")

	def SymName(self, sym: Symbol) -> str:
		assert isinstance(sym, Symbol)
		if sym.name[0].isalpha():
			# real name value is stored in Tab.literals
			for me_key, me_value in Tab.literals.items():
				if me_value == sym:
					return me_key
		return sym.name

	def GenLiterals(self) -> None:
		self.gen.write("lit = self.t.val")
		if self.ignoreCase:
			self.gen.write(".lower()")
		self.gen.write("\n")
		first = True  # boolean
		for sym in Symbol.terminals:
			if sym.tokenKind == Symbol.litToken:
				name = self.SymName(sym)  # String
				if self.ignoreCase:
					name = name.lower()
				# sym.name stores literals with quotes, e.g. "\"Literal\"",
				if first:
					self.gen.write(INDENT * 2 + "if ")
					first = False
				else:
					self.gen.write(INDENT * 2 + "elif ")
				self.gen.write("lit == " + name + ":\n")
				self.gen.write(INDENT * 3 + "self.t.kind = ")
				self.PrintTermName(sym)
				self.gen.write("\n")

	def WriteState(self, state: State) -> None:
		assert isinstance(state, State)
		endOf = state.endOf  # Symbol
		self.gen.write(str(state.nr) + ":\n")
		ctxEnd = state.ctx  # boolean
		action = state.firstAction
		while action is not None:
			if action == state.firstAction:
				self.gen.write(INDENT * 4 + "if ")
			else:
				self.gen.write(INDENT * 4 + "elif ")
			if action.typ == NodeKind.chr:
				self.gen.write(self.ChCond(action.sym))
			else:
				self.PutRange(CharClass.Set(action.sym))
			self.gen.write(":\n")
			if action.tc == Node.contextTrans:
				self.gen.write(INDENT * 5 + "apx += 1\n")
				ctxEnd = False
			elif state.ctx:
				self.gen.write(INDENT * 5 + "apx = 0\n")
			if self.ignoreCase:
				self.gen.write(INDENT * 5 + "buf += str(self.ch)\n")
			else:
				self.gen.write(INDENT * 5 + "buf += str(self.ch)\n")
			self.gen.write(INDENT * 5 + "self.NextCh()\n")
			self.gen.write(INDENT * 5 + "state = " + str(action.target.state.nr) + "\n")
			action = action.next
		if state.firstAction is not None:
			self.gen.write(INDENT * 4 + "else:\n")
		if ctxEnd:  # final context state: cut appendix
			self.gen.write("\n")
			self.gen.write(INDENT * 4 + "self.pos = self.pos - apx - 1\n")
			self.gen.write(INDENT * 4 + "self.line = self.t.line\n")
			self.gen.write(INDENT * 4 + "self.buffer.setPos(self.pos+1)\n")
			self.gen.write(INDENT * 4 + "self.NextCh()\n")
			# self.gen.write(INDENT * 4 +"")
		if state.firstAction is not None:
			if endOf is None:
				self.gen.write(INDENT * 5 + "self.t.kind = ScannerEnum.noSym\n")
				self.gen.write(INDENT * 5 + "done = True\n")
			else:
				self.gen.write(INDENT * 5 + "self.t.kind = ")
				self.PrintTermName(endOf)
				self.gen.write("\n")
				if endOf.tokenKind == Symbol.classLitToken:
					self.gen.write(INDENT * 5 + "self.t.val = buf\n")
					self.gen.write(INDENT * 5 + "self.CheckLiteral()\n")
					self.gen.write(INDENT * 5 + "return self.t\n")
				else:
					self.gen.write(INDENT * 5 + "done = True\n")
		else:
			if endOf is None:
				self.gen.write(INDENT * 4 + "self.t.kind = ScannerEnum.noSym\n")
				self.gen.write(INDENT * 4 + "done = True\n")
			else:
				self.gen.write(INDENT * 4 + "self.t.kind = ")
				self.PrintTermName(endOf)
				self.gen.write("\n")
				if endOf.tokenKind == Symbol.classLitToken:
					self.gen.write(INDENT * 4 + "self.t.val = buf")
					self.gen.write(INDENT * 4 + "self.CheckLiteral()\n")
					self.gen.write(INDENT * 4 + "return self.t\n")
				else:
					self.gen.write(INDENT * 4 + "done = True\n")

	def FillStartTab(self, startTab: List[int]) -> None:
		assert isinstance(startTab, list)
		action = self.firstState.firstAction
		while action is not None:
			targetState = action.target.state.nr  # int
			if action.typ == NodeKind.chr:
				startTab[action.sym] = targetState
			else:
				s = CharClass.Set(action.sym)  # BitSet
				for i in range(0, CharClass.charSetSize):
					if i in s:
						startTab[i] = targetState
			action = action.next

	def OpenGen(self, backUp: bool) -> None:
		assert isinstance(backUp, bool)
		try:
			fn = self.outDir / "Scanner.py"  # String
			if backUp and fn.is_file():
				backUpFile = fn.parent / (fn.name + ".old")
				if backUpFile.is_file():
					os.remove(str(backUpFile))
				os.rename(str(fn), str(backUpFile))
			self.gen = fn.open("wt", encoding="utf-8")
		except BaseException as ex:
			print(ex)
			raise RuntimeError("-- Compiler Error: Cannot generate scanner file.")

	def WriteScanner(self, withNames: bool) -> None:
		assert isinstance(withNames, bool)
		startTab = [0 for i in range(CharClass.charSetSize)]
		fr = self.srcDir / "Scanner.frame"  # String
		if not fr.is_file():
			if Tab.frameDir is not None:
				fr = Tab.frameDir / "Scanner.frame"
			if not fr.is_file():
				raise RuntimeError("-- Compiler Error: Cannot find Scanner.frame")
		try:
			self.fram = open(fr, "rt", encoding="utf-8")
		except BaseException:
			raise RuntimeError("-- Compiler Error: Cannot open Scanner.frame.")
		self.OpenGen(True)
		if self.dirtyDFA:
			self.MakeDeterministic()
		self.FillStartTab(startTab)
		self.CopyFramePart("-->begin")
		if not self.srcName.lower().endswith("coco.atg"):
			self.gen.close()
			self.OpenGen(False)

		self.CopyFramePart("-->scannerenum")
		self.gen.write(INDENT + "charSetSize = " + str(CharClass.charSetSize) + "\n")
		self.gen.write(INDENT + "maxT = " + str(len(Symbol.terminals) - 1) + "\n")
		self.gen.write(INDENT + "noSym = " + str(Tab.noSym.n) + "\n")
		if withNames:
			self.gen.write(INDENT + "# terminals\n")
			for sym in Symbol.terminals:
				self.gen.write(INDENT + "" + sym.symName + " = " + str(sym.n) + "\n")
			self.gen.write(INDENT + "# pragmas\n")
			for sym in Symbol.pragmas:
				self.gen.write(INDENT + "" + sym.symName + " = " + str(sym.n) + "\n")
			self.gen.write("\n")
		self.CopyFramePart("-->declarations")
		self.gen.write(INDENT + "start = [\n")
		for i in range(0, CharClass.charSetSize // 16):
			self.gen.write(INDENT + "")
			for j in range(0, 16):
				self.gen.write(Trace.formatString(str(startTab[16 * i + j]), 3))
				self.gen.write(",")
			self.gen.write("\n")
		self.gen.write(INDENT + "  -1]\n")

		if self.ignoreCase:
			self.gen.write(INDENT + "valCh = ''       # current input character (for token.val)")

		self.CopyFramePart("-->initialization")
		j = 0
		for i in Tab.ignored:
			self.gen.write(INDENT * 2 + "self.ignore.add(" + str(i) + ") \n")

		self.CopyFramePart("-->casing")
		if self.ignoreCase:
			self.gen.write(INDENT * 2 + "valCh = self.ch\n")
			self.gen.write(INDENT * 2 + "if self.ch != Buffer.EOF:\n")
			self.gen.write(INDENT * 3 + "self.ch = self.ch.lower()\n")

		self.CopyFramePart("-->comments")
		com = Comment.first  # Comment
		i = 0
		while com is not None:
			self.GenComment(com, i)
			com = com.next
			i += 1

		self.CopyFramePart("-->literals")
		self.GenLiterals()

		self.CopyFramePart("-->scan1")
		if Comment.first is not None:
			self.gen.write("if (")
			com = Comment.first
			i = 0
			while com is not None:
				self.gen.write(self.ChCond(com.start[0]))
				self.gen.write(" and self.Comment" + str(i) + "()")
				if com.next is not None:
					self.gen.write(" or ")
				com = com.next
				i += 1
			self.gen.write("):\n")
			self.gen.write(INDENT * 3 + "return self.NextToken()\n")
		if self.hasCtxMoves:
			self.gen.write("\n")
			self.gen.write(INDENT * 2 + "apx = 0")

		self.CopyFramePart("-->scan2")
		if self.ignoreCase:
			self.gen.write("buf += str(self.ch)\n")
			self.gen.write(INDENT * 2 + "self.NextCh()\n")
		else:
			self.gen.write("buf += str(self.ch)\n")
			self.gen.write(INDENT * 2 + "self.NextCh()\n")

		self.CopyFramePart("-->scan3")
		state = self.firstState.next
		while state is not None:
			self.gen.write(INDENT * 3 + "elif state == ")
			self.WriteState(state)
			state = state.next
		self.CopyFramePart("$$$")
		self.gen.close()

	def __init__(self, file: str, srcDir: Path, outDir: Path, trace) -> None:
		assert isinstance(file, str), repr(str)
		assert isinstance(srcDir, Path), repr(srcDir)
		assert isinstance(outDir, Path), repr(outDir)
		self.trace = trace
		self.srcName = file
		self.srcDir = srcDir
		self.outDir = outDir
		self.firstState = None
		self.lastState = None
		State.lastNr = -1
		self.firstState = self.NewState()
		Melted.first = None
		Comment.first = None
		self.ignoreCase = False
		self.dirtyDFA = False
		self.hasCtxMoves = False

	def PrintTermName(self, sym: Symbol) -> None:
		assert isinstance(sym, Symbol)
		if sym.symName is None:
			self.gen.write(str(sym.n))
		else:
			self.gen.write("ScannerEnum.")
			self.gen.write(str(sym.symName))
